# 2. Основные понятия операционной системы (ОС).

Все работы организуются как взаимодействие отдельных процессов.\
Процесс – единица потребления ресурсов.\
Процесс – программа, выполняемая в своём виртуальном пространстве.\
&#xNAN;_&#x41F;роцесс_ – последовательность операций программы на этапе её исполнения \
(программа&#x20;\= исполняемый код).

Каждой программе в любой момент времени может соответствовать один или несколько процессор или не соответствовать ни одного. Процесс - последовательность операций, никакие асинхронные действия в рамках процесса не допустимы. Распределение ресурсов между процессами выполняется резидентной частью операционной системы, которая носит название _ядра_&#x20;

Ядро состоит из 2 секций:

1. Секция управляющих структур (системные таблицы);
2. Программная секция:
   1. Машинно-независимая часть (написана на Си, по разным оценкам примерно 90-92% кода)
   2. Машинно-зависимая часть (смесь Си и Ассемблера)

Ядро управляет всеми ресурсами.&#x20;

Функции ядра:&#x20;

* Инициализация системы.
* Управление процессами: их создание, синхронизация, диспетчеризация и взаимодействие процессов между собой.
* Планирование очередности предоставления процессам времени центрального процессора (ЦП) по некоторому алгоритму в режиме разделения (квантования) времени (диспетчеризация).
* Выделение выполняемому процессу оперативной памяти и управление свопингом.&#x20;
* Выделение внешней памяти с целью обеспечения эффективного хранения и выборки информации.&#x20;
* Доступ процессов к периферийным устройствам (диски, терминалы, сетевое оборудование).
* Прием от процессов запросов на обслуживание.

Ядро не занимается обслуживанием пользователей, для этого сузествует специальный аппарат - набор системных программ - утилит, выступающих в качестве посредника между ядром и пользователем.&#x20;

Ядро становится относительно компактным (по различным оценкам 10-15 тыс. строк на языке Си, 2-3 тыс. строк на языке Ассемблер). Учитывая, что ядро можно конфигурировать и компилировать "под себя", а часть фукнций можно выделить в подгружаемые модули, то можно добиться значительного уменьшения размера ядра.

<figure><img src="../../.gitbook/assets/image (2).png" alt=""><figcaption><p>Рис 1.</p></figcaption></figure>

Выполнение пользовательских процессов в OC UNIX осуществляется на 2 уровнях:

* _уровень пользователя_ (пользовательский режим, режим задачи, пользовательская фаза):
* _уровень ядра_ (системный режим, режим ядра, системная фаза)

Когда процесс обращается к ОС для получения некоторого сервиса, режим выполнения процесса переключается с режима задачи на режим ядра. Смена режима не связана с порождением нового процесса, а является лишь иным состоянием исходного процесса.&#x20;

<figure><img src="../../.gitbook/assets/image (3).png" alt=""><figcaption><p>Рис 2.</p></figcaption></figure>

Даже если пользовательские процессы не используют системные вызовы, ядро все равно каждый раз запускает режим ядра от имени пользователя.&#x20;

Отличия этих режимов:

1. В режиме задачи процессы имеют доступ только к своим собственным командам и к своим данным, и не имеют доступа к командам и данным ядра и других процессов. В режиме ядра процессам доступны адресные пространства как ядра, так и всех пользовательских процессов.&#x20;
2. В пользовательском режиме не могут выполняться некоторые привилегированные команды, доступные только в режиме ядра (например, управление регистрами процессора).
3. Процессу, функционирующему в системной фазе, соответствует реентерабельный (re|enter|able - программа, допускающая повторных вход) код ядра, в пользовательской фазе процессу соответствует пользовательский код программы.&#x20;

Что такое реентерабельные программы: Рассмотрим на примере:

<figure><img src="../../.gitbook/assets/image (4).png" alt=""><figcaption><p>Рис 3. Пример реентерабельного процесса</p></figcaption></figure>

Пусть процессы 1 и 2 - два процесса одной и той же программы. Процесс 1 выполняется до точки А, после чего система передает управление процессу 2, который доходит до точки B. После того, как управление вернется процессу 1, он должен продолжить свое выполнение с момента A. Кроме того, если процесс 1 изменяет какие-либо данные, то это никак не должно отразиться на работе процесса 2.&#x20;

В связи с особенностями реентерабельных программ, возникают некоторые ограничения:

* Программа не модифицирует себя, свои данные;
* Никакие данные внутри программы не используются;
* Все нужные данные программа запрашивает динамически;
* Каждый вариант программы работает со своими отдельными данными.

Пример на переключение режимов:

Интерпретатор команд читает входной поток данных с терминала. Интерпретатор (shell) в режиме задачи (task) посылает запрос к ОС для работы с данным устройством. От имени Shell в режиме ядра (kern) запускается процесс, работающий с устройством (в данном случае - с клавиатурой), выполняющий чтение символов. Как только ввод заканчивается, процесс, отвечающий за ввод, завершается и Shell снова переходит в режим задачи, а затем интерпретирует команды (распознает входную последовательность) и осуществляет вызов некоторой программы в соответствии с командой пользователя.&#x20;

Данный процесс можно проиллюстрировать схемой:

{% stepper %}
{% step %}
### Shell (task)
{% endstep %}

{% step %}
### Запрос к ОС
{% endstep %}

{% step %}
### От имени Shell (kern) запускается процесс, работающий с клавиатурой (чтение символов)
{% endstep %}

{% step %}
### Shell (task) - интерпретация команд
{% endstep %}

{% step %}
### Вызов некоторой программы
{% endstep %}
{% endstepper %}

Нормальное состояние любого пользовательского процесса (в том числе и Shell) - режим задачи (task). Для работы с устройствами используется режим ядра (kern).

Поскольку система UNIX - система разделения времени, и основной ее задачей является поддержание множества программ, находящихся в различных стадиях выполнения, то предоставление услуг ядра этим программам должно выполняться наиболее безопасным образом. Таким безопасным механизмом является механизм системных вызовов.

_**Механизм системных вызовов**_ - то, посредством чего можно запросить некоторые ресурсы ядра. В любом случае, как бы механизм обработки вызовов к ядру не назывался, он выливается в обработку прерываний.&#x20;

Рассмотрим две функции: библиотечную и системный вызов.&#x20;

1. nread = fread (inputbuf, OBJSIZE, num, filter) - библиотечная функция.
2. nread = read (field, inputbuf, BUFSIZE) - системный вызов.&#x20;

Механизм работы этих функций проиллюстрируем схемой:

<figure><img src="../../.gitbook/assets/image (5).png" alt=""><figcaption><p>Рис 4. Схема работы функций</p></figcaption></figure>

Как правило, командам shell соответствуют системные вызовы. Но есть команды без системных вызовов и системные вызовы, которым не соответствуют команды.&#x20;

<figure><img src="../../.gitbook/assets/image (6).png" alt=""><figcaption><p>Рис 5. Команды ≠ системные вызовы</p></figcaption></figure>

В системе UNIX одновременно выполняется множество процессов, при этом некоторые из них могут одновременно выполняться в режиме ядра. Возможен случай, что некоторые процессы будут одновременно работать с системными таблицами. Некоторые участки системных фаз являются критическими в том смысле, что пока один процесс не вышел из критического участка, другой процесс не может в него войти. Данный механизм используется для обеспечения целостности ядра.&#x20;

Для синхронизации процессов в системной фазе используется аппарат событий, который доступен только в системной фазе и не доступен в режиме пользователя.&#x20;

В ОС UNIX используется простейший вариант механизма аппарата событий, когда процесс, приостановленный от лица некоторого другого процесса, размораживается только этим процессом.&#x20;

Система UNIX позволяет ряду внешних устройств асинхронно прерывать работу центрального процессора (ЦП) в соответствии с жестко заданной системой приоритетов.&#x20;

Общая схема: По получении сигнала прерывания, ядро ОС сохраняет свой контекст, определяет причину прерывания, обрабатывает это прерывание, после чего восстанавливает свой старый контекст. В процессе обработки прерываний ядро учитывает приоритет прерываний и при их обработке блокирует прерывания более низкого уровня.&#x20;

Система прерываний следующая: (в порядке убывания)

* Машинные сбои
* Системные часы
* Дисковые операции
* Сетевое оборудование
* Терминал
* Программные прерывания
